/*!
 * nodeUpload
 * Copyright(c) 2012 Nibs Solution (BD) Ltd. <drubo@nibssolution.com>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var EventEmitter = process.EventEmitter,
	fs = require('fs'),
	sanitize = require('validator').sanitize,
	exec = require("child_process").exec;

/**
 * Export the constructor.
 */

exports = module.exports = Manager;

/**
 * Default transports.
 */

var defaultTransports = exports.defaultTransports = [
    'websocket' //done
  , 'flash' //done
  , 'htmlfile'
  , 'xhr-polling'
  , 'jsonp-polling'
];

var uploadFile = {
	  size: 0
	, index: 0
	, file: ''
	, exists: false
	, name: ''
	, ext: ''
	, inProgress: false
	, storagePath: '/tmp/'
};

var allowed_types = "hqx|cpt|csv|bin|dms|lha|lzh|exe|class|psd|";
allowed_types += "so|sea|dll|oda|pdf|ai|eps|ps|smi|smil|mif|xls|ppt|wbxml|wmlc|dcr|dir|dxr|dvi|";
allowed_types += "gtar|gz|js|swf|sit|tar|tgz|xhtml|xht|zip|mid|midi|";
allowed_types += "mpga|mp2|mp3|aif|aiff|aifc|ram|rm|rpm|ra|rv|wav|bmp|gif|";
allowed_types += "jpeg|jpg|jpe|png|tiff|tif|css|html|htm|shtml|txt|text|log|";
allowed_types += "rtx|rtf|xml|xsl|mpeg|mpg|mpe|qt|mov|avi|movie|doc|docx|xlsx|word|xl|eml|odp";

/**
 * Inherited defaults.
 */

var parent = module.parent.exports;

/**
 * Manager constructor.
 *
 * @param {HTTPServer} server
 * @param {Object} options, optional
 * @api public
 */

function Manager (server, options) {
  this.server = server;
  this.settings = options;

  var self = this;

  // default error handler
  server.on('error', function(err) {
    console.log('error raised: ' + err);
  });

  // reset listeners
  this.oldListeners = server.listeners('request');
  server.removeAllListeners('request');

  server.on('request', function (req, res) {
    self.handleRequest(req, res);
  });
};

Manager.prototype.__proto__ = EventEmitter.prototype;

Manager.prototype.handleRequest = function(request, response){
	var self = this;
	if (!this.originIsAllowed(request.origin)) {
		// Make sure we only accept requests from an allowed origin
		request.reject();
		console.log((new Date()) + ' Connection from origin ' + request.origin + ' rejected.');
		return;
	}

	var connection = request.accept('fus', request.origin);
	console.log(connection.remoteAddress + " connected - Protocol Version " + connection.websocketVersion);
	
	connection.on('message', function(message) {
		self.handleMessage(message, connection);
	});
	
	connection.on('close', function(reasonCode, description) {
		console.log((new Date()) + ' Peer ' + connection.remoteAddress + ' disconnected.');
	});
	
	connection.on('error', function(err){
		connection.close();
		console.log(err);
	});
};

Manager.prototype.originIsAllowed = function(origin){
	var trustedOrigins = {};
	var trustedOriginsWithPort = this.settings.origins.split('||');
	trustedOriginsWithPort.forEach(function(item){
		var host = item.split(':');
		trustedOrigins["http://"+host[0]] = '';
	});
	return origin in trustedOrigins;
};

Manager.prototype.handleMessage = function (message, connection){
    if (message.type === 'utf8') {
    	var args = message.utf8Data.split(/=>/);
        var control = args.shift();
        var params = args[0].split('||');
        if(uploadFile.inProgress && control=='upload'){
			var edata = new Buffer(params[1], 'base64');
        	if(params[0]==undefined){
        		uploadFile.file.write(edata);
        		uploadFile.index = sanitize(uploadFile.index + params[1].length).toInt();
        		connection.sendUTF("response=>upload||"+uploadFile.index);
        	}else{
            	if(params[1].length!=params[0]){
            		connection.sendUTF("response=>upload||"+uploadFile.index);
            	}else{
            		uploadFile.file.write(edata);
            		uploadFile.index = sanitize(uploadFile.index + edata.length).toInt();
                	connection.sendUTF("response=>upload||"+uploadFile.index);
                	if(uploadFile.index >= uploadFile.size){
                		uploadFile.inProgress = false;
                		uploadFile.file.end();
                		console.log('Upload Finished.');
                		this.addJob(uploadFile.name); //Adds Job to BeansTalk
                		if(uploadFile.index>uploadFile.size){
                			connection.sendUTF("error=>Error in Upload. Please try again later...");
                			connection.close();
                		}
                	}
            	}            		
        	}
        }
        if(control=='query'){
        	if(params[0]=='exist'){
        		uploadFile.name = uploadFile.storagePath+params[1];
        		var parts = params[1].split('.');
        		uploadFile.ext = parts[parts.length-1];
        		//Check for valid user
        			//@TODO Tareq: implement user check here...
        		
        		//Check for Size Limit
        		if(params[2]>this.settings.maxFileSize){
        			connection.sendUTF("error=>This file is too large to upload...");
        			connection.close();
        			return;
        		}
        		
        		//Check for valid file type
        		var ary = allowed_types.split('|');
        		var test = uploadFile.ext in this.oc(ary);
        		if (!test) {
        			connection.sendUTF("error=>You are not allowed to upload this type of file.");
        			connection.close();
        		}else{
            		//Check for file existance
            		fs.stat(uploadFile.name, function(err, stats){
            			if(err==null){
            				connection.sendUTF("response=>exist||"+stats.size);
            				uploadFile.exists = true;
            			}else{
            				connection.sendUTF("response=>exist||0");
            				uploadFile.exists = false;
            			}
            		});
        		}
        	}
        }
        if(control=='command'){
        	if(params[0]=='upload'){
        		uploadFile.name =  uploadFile.storagePath+params[1];
        		var parts = params[1].split('.');
        		uploadFile.ext = parts[parts.length-1];
        		uploadFile.size = params[2];
        		uploadFile.index = params[3];
        		if(uploadFile.index==0){ //ReUpload
            		if(uploadFile.exists){
            			fs.unlink(uploadFile.name);
            		}
        		}
        		uploadFile.file = fs.createWriteStream(uploadFile.name, {'flags': 'a', encoding: 'binary', mode: 0666});
        		fs.stat(uploadFile.name, function(err, stats){
        			if(err==null){
        				uploadFile.inProgress = true;
        			}else{
        				connection.sendUTF("error=>Failed to open file on server");
        				connection.close();
        			}
        		});
        	}
        	if(params[0]=='stop'){
        		uploadFile.file.end();
        		console.log('Upload Cancelled..');
        		connection.close();
        	}
        	if(params[0]=='allowedTypes'){
        		allowed_types = params[1];
        	}
        }
    }
    else if (message.type === 'binary') {
        console.log('Received Binary Message of ' + message.binaryData.length + ' bytes');
        //connection.sendBytes(message.binaryData);
    }
};

Manager.prototype.oc = function(a){
  var o = {};
  for(var i=0;i<a.length;i++)
  {
    o[a[i]]='';
  }
  return o;
};

Manager.prototype.getRandomName = function(src) {
	var uniq_id = require('crypto').createHash('md5').update(src + Math.floor(Math.random() * 0x100000000) + (new Date()).getTime()).digest("hex");
	return uniq_id;
};

Manager.prototype.addJob = function(src){
	var tubeName='';
	var dest=this.getRandomName(src);
	var jobFile = dest +'.php';
	var newName = uploadFile.storagePath+dest+'.'+uploadFile.ext;
	fs.rename(src, newName);
	
	switch(uploadFile.ext){
	case 'pdf':
		tubeName = 'pdf_conversion';
		break;
	case 'ppt':
	case 'pptx':
	case 'odp':
		tubeName = 'ppt_conversion';
		break;
	case 'mpeg':
	case 'mpg':
	case 'mpe':
	case 'mov':
		tubeName = 'video_conversion';
		break;
	default:
		tubeName = 'fs';
		dest += '.'+uploadFile.ext;
	}
	
	var phpFile = fs.createWriteStream(jobFile, {'flags': 'a', encoding: 'utf8', mode: 0666});
	phpFile.write("<?php  require('lib/beanstalk.php');");
	phpFile.write("$beanstalk = new Beanstalk();");
	phpFile.write("$beanstalk->connect();");
	phpFile.write("$beanstalk->useTube('"+tubeName+"');");
	if(tubeName == 'fs'){
		phpFile.write("$data = array('type'=>'move','src'=>'"+newName+"','dest'=>'"+dest+"');");
	}else{
		phpFile.write("$data = array('src'=>'"+newName+"','dest'=>'"+dest+"','del_source'=>true);");
	}
	phpFile.write("$beanstalk->put(0,0,120,json_encode($data));");
	phpFile.write("?>");
	phpFile.end();
	exec("php "+jobFile, function (error, stdout, stderr){
		 fs.unlink(jobFile);
	});
};