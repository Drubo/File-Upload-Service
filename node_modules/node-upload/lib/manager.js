/*!
 * nodeUpload
 * Copyright(c) 2012 Nibs Solution (BD) Ltd. <drubo@nibssolution.com>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var EventEmitter = process.EventEmitter,
	fs = require('fs'),
	sanitize = require('validator').sanitize,
	common_file = require("./common");

/**
 * Export the constructor.
 */

exports = module.exports = Manager;

/**
 * Default transports.
 */

var defaultTransports = exports.defaultTransports = [
    'websocket' //done
  , 'flash' //done
  , 'htmlfile'
  , 'xhr-polling'
  , 'jsonp-polling'
];

var uploadFile = {
	  size: 0
	, index: 0
	, file: ''
	, exists: false
	, name: ''
	, ext: ''
	, inProgress: false
	, storagePath: '/tmp/'
};

/**
 * Inherited defaults.
 */

var parent = module.parent.exports;

/**
 * Manager constructor.
 *
 * @param {HTTPServer} server
 * @param {Object} options, optional
 * @api public
 */

function Manager (server, options) {
  this.server = server;
  this.settings = options;
  
  this.common = new common_file(this.settings);

  var self = this;

  // default error handler
  server.on('error', function(err) {
    console.log('error raised: ' + err);
  });

  // reset listeners
  this.oldListeners = server.listeners('request');
  server.removeAllListeners('request');

  server.on('request', function (req, res) {
    self.handleRequest(req, res);
  });
};

Manager.prototype.__proto__ = EventEmitter.prototype;

Manager.prototype.handleRequest = function(request, response){
	var self = this;
	if (!this.common.originIsAllowed(request.origin)) {
		// Make sure we only accept requests from an allowed origin
		request.reject();
		console.log((new Date()) + ' Connection from origin ' + request.origin + ' rejected.');
		return;
	}

	var connection = request.accept('fus', request.origin);
	console.log(connection.remoteAddress + " connected - Protocol Version " + connection.websocketVersion);
	
	connection.on('message', function(message) {
		self.handleMessage(message, connection);
	});
	
	connection.on('close', function(reasonCode, description) {
		console.log((new Date()) + ' Peer ' + connection.remoteAddress + ' disconnected.');
	});
	
	connection.on('error', function(err){
		connection.close();
		console.log(err);
	});
};

Manager.prototype.handleMessage = function (message, connection){
    if (message.type === 'utf8') {
    	var args = message.utf8Data.split(/=>/);
        var control = args.shift();
        var params = args[0].split('||');
        if(uploadFile.inProgress && control=='upload'){
			var edata = new Buffer(params[1], 'base64');
        	if(params[0]==undefined){
        		uploadFile.file.write(edata);
        		uploadFile.index = sanitize(uploadFile.index + params[1].length).toInt();
        		connection.sendUTF("response=>upload||"+uploadFile.index);
        	}else{
            	if(params[1].length!=params[0]){
            		connection.sendUTF("response=>upload||"+uploadFile.index);
            	}else{
            		uploadFile.file.write(edata);
            		uploadFile.index = sanitize(uploadFile.index + edata.length).toInt();
                	connection.sendUTF("response=>upload||"+uploadFile.index);
                	if(uploadFile.index >= uploadFile.size){
                		uploadFile.inProgress = false;
                		uploadFile.file.end();
                		console.log('Upload Finished.');
                		this.common.addJob(uploadFile); //Adds Job to BeansTalk
                		if(uploadFile.index>uploadFile.size){
                			connection.sendUTF("error=>Error in Upload. Please try again later...");
                			connection.close();
                		}
                	}
            	}            		
        	}
        }
        if(control=='query'){
        	if(params[0]=='exist'){
        		uploadFile.name = uploadFile.storagePath+params[1];
        		var parts = params[1].split('.');
        		uploadFile.ext = parts[parts.length-1];
        		//Check for valid user
        			//@TODO Tareq: implement user check here...
        		
        		//Check for Size Limit
        		if(params[2]>this.settings.maxFileSize){
        			connection.sendUTF("error=>This file is too large to upload...");
        			connection.close();
        			return;
        		}
        		
        		//Check for valid file type
        		var ary = this.settings.allowed_types.split('|');
        		var test = uploadFile.ext in this.common.oc(ary);
        		if (!test) {
        			connection.sendUTF("error=>You are not allowed to upload this type of file.");
        			connection.close();
        		}else{
            		//Check for file existance
            		fs.stat(uploadFile.name, function(err, stats){
            			if(err==null){
            				connection.sendUTF("response=>exist||"+stats.size);
            				uploadFile.exists = true;
            			}else{
            				connection.sendUTF("response=>exist||0");
            				uploadFile.exists = false;
            			}
            		});
        		}
        	}
        }
        if(control=='command'){
        	if(params[0]=='upload'){
        		uploadFile.name =  uploadFile.storagePath+params[1];
        		var parts = params[1].split('.');
        		uploadFile.ext = parts[parts.length-1];
        		uploadFile.size = params[2];
        		uploadFile.index = params[3];
        		if(uploadFile.index==0){ //ReUpload
            		if(uploadFile.exists){
            			fs.unlink(uploadFile.name);
            		}
        		}
        		uploadFile.file = fs.createWriteStream(uploadFile.name, {'flags': 'a', encoding: 'binary', mode: 0666});
        		fs.stat(uploadFile.name, function(err, stats){
        			if(err==null){
        				uploadFile.inProgress = true;
        			}else{
        				connection.sendUTF("error=>Failed to open file on server");
        				connection.close();
        			}
        		});
        	}
        	if(params[0]=='stop'){
        		uploadFile.file.end();
        		console.log('Upload Cancelled..');
        		connection.close();
        	}
        	if(params[0]=='allowedTypes'){
        		this.settings.allowed_types = params[1];
        	}
        }
    }
    else if (message.type === 'binary') {
        console.log('Received Binary Message of ' + message.binaryData.length + ' bytes');
        //connection.sendBytes(message.binaryData);
    }
};