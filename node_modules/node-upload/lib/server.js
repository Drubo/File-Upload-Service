/*!
 * nodeUpload
 * Copyright(c) 2012 Nibs Solution (BD) Ltd. <drubo@nibssolution.com>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */
var WebSocketServer = require('websocket').server,
	http = require('http'),
	node_static = require('node-static'),
	EventEmitter = process.EventEmitter,
	uaParser = require('ua-parser'),
	pf = require('policyfile'),
	fs = require('fs'),
	formidable = require('formidable');

var uploadServer = function uploadServer(host, port, options, fn){
	var self = this;
	this.host = host;
	this.port = port;
	this.options = options;
	
	var origins = this.oc(this.options.origins.split("||"));
	
	var clientFiles = new(node_static.Server)();
	
	var server = http.createServer(function(request, response) {
		console.log(request.url);
		if (request.headers.accept && request.headers.accept == 'text/event-stream') {
		  if (request.url == '/stream') {
		    this.sendSSE(request, response);
		  } else {
		    resquest.writeHead(404);
		    resquest.end();
		  }
		}else{
			if (request.url == '/upload' && request.method.toLowerCase() == 'post') {
				  console.log('Multipart/FormData is in Progress');
	
				  // parse a file upload
				  var form = new formidable.IncomingForm();
				  form.uploadDir = '/tmp';
				  form.encoding = 'binary';
				  form.keepExtensions = true;
			  
				  form.addListener('file', function(name, file) {
					// do something with uploaded file
					  //console.log(file);
				  });
				  
				  form.addListener('progress', function(bytesReceived, bytesExpected){
					  // CORS Access
					  if(request.headers.origin.substr(7) in origins){
						  response.writeHead(200, {'Access-Control-Allow-Origin': '*'});
					  }
					  var progress = {
							  type: 'progress',
							  loaded: bytesReceived,
							  total: bytesExpected
					  };
					  //response.writeHead(200, {'Content-Length': msg.length, 'Content-Type': 'text/javascript' });
					  response.write('"'+progress+'"');
					  response.end();
					  console.log(progress);
				  });
				  
				  form.addListener('error', function(err){
					 console.log(err); 
				  });
				  
				  form.addListener('end', function() {
					console.log('Multipart/FormData upload Complete');
				    response.end();
				  });
				  
				  form.parse(request, function(err, fields, files) {
					if(err){
				    	console.log(err);
				    }
				  });
				}else{
					request.addListener('end', function () {
						clientFiles.serve(request, response, function(err, res){
				        	if(err){
				        		var breakup = request.url.split('?');
				        		if(breakup[0]=='/client.js'){
				        			var result = breakup[1].split('&');
					        		var ary = self.oc(result);
					        		var body = '';
					        		if(ary.fileReader=='true'){
						        		if(ary.webSocket=='true'){
					        				//body = self.serveWebSocket();
						        			body = self.serveXhrPollingFormData();
						        		}else{
						        			if(ary.flash=='true'){
						        				body = self.serveFlash();
						        			}else{
						        				if(ary.xhr_polling=='true'){
						        					body = self.serveXhrPollingFormData();
						        				}else{
						        					body = self.serveIFrame();
						        				}
						        			}
						        		}
					        		}else{
					        			body = self.serveIFrame();
					        		}
						        	response.writeHead(200, {'Content-Length': body.length, 'Content-Type': 'text/javascript' });
									response.write(body);
									response.end();
								}else if(breakup[0]=='/event.js'){
									var body = "var source = new EventSource('/stream');";
									response.writeHead(200, {'Content-Length': body.length, 'Content-Type': 'text/javascript' });
									response.write(body);
									response.end();
								}else{
									if(request.url!='/favicon.ico'){
						        		console.log("Error serving " + request.url + " - " + err.message);
									}
								}
				        	}
				        });
					});
				}
		}
	});
	if('undefined' == typeof fn){
		server.listen(port, host, function() {
			console.log('Web Socket Server is listening on '+host+' port '+port);
		});
	}else{
		server.listen(port, host, fn);
	}
	
	if(options.flashPolicyServer){
		pf.createServer().listen(1337, server);
	}

	self.wsServer = new WebSocketServer({
	    httpServer: server,
	    // You should not use autoAcceptConnections for production
	    // applications, as it defeats all standard cross-origin protection
	    // facilities built into the protocol and the browser.  You should
	    // *always* verify the connection's origin and decide whether or not
	    // to accept it.
	    autoAcceptConnections: false,
	    maxReceivedMessageSize: 0x40000000, // 1GiB
	    //assembleFragments: false // stream!!
	});
	
	return self.wsServer;
}

module.exports = uploadServer;
uploadServer.prototype.__proto__ = EventEmitter.prototype

uploadServer.prototype.oc = function(a){
  var o = {};
  for(var i=0;i<a.length;i++)
  {
    var c = a[i].split('=');
	o[c[0]]=c[1];
  }
  return o;
}

uploadServer.prototype.sendSSE = function (request, response){
	response.writeHead(200, {
	    'Content-Type': 'text/event-stream',
	    'Cache-Control': 'no-cache',
	    'Connection': 'keep-alive'
	  });

	  var id = (new Date()).toLocaleTimeString();

	  // Sends a SSE every 5 seconds on a single connection.
	  setInterval(function() {
	    this.constructSSE(response, id, (new Date()).toLocaleTimeString());
	  }, 5000);

	  this.constructSSE(response, id, (new Date()).toLocaleTimeString());
};

uploadServer.prototype.constructSSE = function(response, id, data){
	response.write('id: ' + id + '\n');
	response.write("data: " + data + '\n\n');
};

uploadServer.prototype.serveWebSocket = function(){
	var data = fs.readFileSync('js/machanism.js', 'utf8');
	data += 'window.WebSocket = window.WebSocket || window.MozWebSocket;';
	data += fs.readFileSync('js/web_socket_client.js', 'utf8');
	data += 'var wsfu = new WebSocketFileUploader(".file_uploader", '+this.options.chunkSize+');';
	data += 'wsfu.initialize();'
	data = data.replace(/hostFromServer/g,'"'+this.host+':'+this.port+'"');
	
	return data;
}

uploadServer.prototype.serveFlash = function(){
	var data = 'WEB_SOCKET_SWF_LOCATION = "js/WebSocketMain.swf";WEB_SOCKET_DEBUG = true;FILE_API_DEBUG = true;';
	data += 'FILE_API_SWF_LOCATION = "js/FileAPI.swf";';
	data += fs.readFileSync('js/swfobject.js', 'utf8');
	data += fs.readFileSync('js/web_socket.js', 'utf8');
	data += fs.readFileSync('js/web_socket_client.js', 'utf8');
	data += fs.readFileSync('js/machanism_file_api.js', 'utf8');
	data += 'var wsfu = new WebSocketFileUploader(".file_uploader", '+this.options.chunkSize+');';
	data += 'wsfu.initialize();'
	data += fs.readFileSync('js/file_api.js', 'utf8');

	data = data.replace(/hostFromServer/g,'"'+this.host+':'+this.port+'"');

	return data;
}

uploadServer.prototype.serveFlashFileReader = function(){
	var data = 'FILE_API_DEBUG = true;';
	data += 'FILE_API_SWF_LOCATION = "js/FileAPI.swf";';
	data += fs.readFileSync('js/swfobject.js', 'utf8');
	data += fs.readFileSync('js/web_socket_client.js', 'utf8');
	data += fs.readFileSync('js/machanism_file_api.js', 'utf8');
	data += 'var wsfu = new WebSocketFileUploader(".file_uploader", '+this.options.chunkSize+');';
	data += 'wsfu.initialize();'
	data += fs.readFileSync('js/file_api.js', 'utf8');

	data = data.replace(/hostFromServer/g,'"'+this.host+':'+this.port+'"');

	return data;
}

uploadServer.prototype.serveXhrPollingFormData = function(){
	var data = fs.readFileSync('js/xhr_polling_form_data.js', 'utf8');
	data = data.replace(/hostFromServer/g,this.host+':'+this.port);
	//data += "var source = new EventSource('/stream');";
	//data += "source.addEventListener('progress', function(e){console.log(e);}, false);";
	
	return data;
}

uploadServer.prototype.serveXhrPollingMutipart = function(){
	var txt = 'alert("Fallback to Xhr Polling with Mutipart. Under Construction.");';
	return txt;
}

uploadServer.prototype.serveIFrame = function(){
	var data = fs.readFileSync('js/formidable.js', 'utf8');
	data = data.replace(/hostFromServer/g,this.host+':'+this.port);
	
	return data;
}